---
title: "Validación EPSOC"
author: "Cristóbal Moya"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    number_sections: true
---

# Introducción

Este documento consiste en una revisión del proceso de validación de EPSOC 2018. Se trata de un documento reproducible y dinámico que será actualizado cada vez que haya una nueva entrega de datos durante el trabajo de campo. El código está inserto dentro del documento, pero replegado. Para verlo hacer click en cuadro `code`.

# Preámbulo

Se cargan los datos en el formato entregado y se homogeneiza el formato en minúscula y usando puntos ("`.`") para separar en vez de guiones bajos ("`_`").

```{r cargar}
pacman::p_load(tidyverse, lubridate, anytime, chron,
               haven, sf,
               sjlabelled, sjmisc, 
               validate, eeptools, kableExtra, janitor, here,
               captioner)

if(Sys.info()[["user"]] == 'caayala'){
  path <- "/Users/caayala/Dropbox (DESUC)/DESUC/Proyectos/3 Políticas Públicas/EPSOC 2018/BD/"
} else if(Sys.info()[["user"]] == 'Andres') {
  path <- "/Users/Andres/Dropbox (DESUC)/Proyectos/3 Políticas Públicas/EPSOC 2018/BD/"
}

epsoc4 <-haven::read_spss(paste0(path, '181122 - EPSOC Base parcial 5.sav')) %>% 
  clean_names() %>% 
  mutate(region = folio %/% 100000)

names(epsoc4) <- tolower(gsub("_", ".", names(epsoc4)))
```

```{r funciones}
kable_estilo <- function(tabla){
  tabla %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                              full_width=F)
}
```

```{r etiquetas}
makeVlist <- function(dta) { 
        labels <- sapply(dta, function(x) attr(x, "label"))
        tibble(name = names(labels),
               label = labels)
        
}  ## Etiquetas variables
labs.epsoc4 <- makeVlist(epsoc4)
labs.epsoc4 <- labs.epsoc4 %>% 
  mutate(label2 = map_chr(label, toString))

labs.epsoc <- get_label(epsoc4)
```

# General

La actual base cuenta con `r dim(epsoc4)[1]` casos recogidos entre el `r min(as.Date(epsoc4$date))` y el `r max(as.Date(epsoc4$date))`. 

```{r entrev_regiones}
epsoc4 %>% 
  count(region, status) %>% 
  spread(status, n) %>% 
  janitor::adorn_totals(where = c('row', 'col')) %>% 
  kable() %>% 
  kable_estilo()
```


## Duración entrevistas

La distribución de la duración de las entrevistas registrada por las tablets se puede ver en la siguiente figura.

```{r}
homologar_fechas <- function(fecha){
  fecha %>% 
    str_replace_all(c("^\\D{3} " = "", '(.*)(\\d{4}$)' = '\\2 \\1')) %>% 
    anytime::anytime()
}

epsoc4 <- epsoc4 %>% 
  mutate_at(vars(starts_with('time')), homologar_fechas)
```


```{r duracion, warning=F}
epsoc4 <- epsoc4 %>% 
  mutate(duration = str_replace_all(duration, c('-' = '', '^(\\d{2})' = '0\\.\\1'))) %>% 
  separate(duration, into = c('dura.d', 'duracion'), sep = '\\.', convert = TRUE, remove = FALSE) %>% 
  mutate(duracion.t = as.duration(hms(duracion) + hms(hms::hms(hour = (24 * dura.d)))))

epsoc4$duracion.t.min <- epsoc4$duracion.t@.Data/60

epsoc4 %>% 
  ggplot(aes(x = duracion.t.min)) + 
  geom_histogram(binwidth = 5) +
  theme_bw() +
  ggtitle("Distribución duración entrevistas por región (escala truncada < 150 minutos)") +
  labs(x = "Duración total entrevista (minutos)",
       y = "Frecuencia") +
  coord_cartesian(xlim = 0:150) +
  scale_x_continuous(breaks = seq(0, 150, by = 15)) +
  facet_grid(as_factor(region) ~ .)
```

Existen `r length(epsoc4$folio[epsoc4$duracion.t.min < 20])` entrevistas que duran menos de 20 minutos, estas debieran ser supervisadas.

```{r}
epsoc4 %>%
  filter(as.double(duracion.t.min) < 20) %>%
  select(folio, duracion.t.min) %>% 
  knitr::kable(col.names = c("Folio", "Duración (minutos)"),
               caption = "Entrevistas de menos de 20 minutos",
               digits = 1) %>% 
  kable_estilo() %>% 
  column_spec(1, width = "10em") %>% 
  column_spec(2, width = "10em")
```

Existen `r length(epsoc4$folio[epsoc4$duracion.t.min > 150])` entrevistas que duran más de 150 minutos, estas debieran ser supervisadas.

```{r ent.largas}
epsoc4 %>%
  filter(as.double(duracion.t.min) > 150) %>%
  transmute(folio, duracion.t.min / 60) %>% 
  knitr::kable(col.names = c("Folio", "Duración (horas)"),
               caption = "Entrevistas de más de 150 minutos",
               digits = 1) %>% 
  kable_estilo() %>% 
  column_spec(1, width = "10em") %>% 
  column_spec(2, width = "10em")
```

## Georeferrenciación

`r ifelse(sum(is.na(epsoc4$latitude)) == 0, "No existen entrevistas sin datos de georreferenciación", paste("Existen", sum(is.na(epsoc4$latitude))))` entrevistas sin datos de georreferenciación:

```{r}
epsoc4 %>% 
  select(folio, latitude, srvyr) %>% 
  group_by(srvyr) %>% 
  mutate(n.enc = length(folio)) %>% 
  filter(is.na(latitude)) %>%
  select(folio, srvyr, n.enc) %>% 
  mutate(n.enc.sg = (length(folio)/n.enc)*100) %>%       
  arrange(srvyr, folio) %>% 
  group_by_at(vars(-folio)) %>% 
  nest() %>% 
  mutate(Folio = map_chr(data, ~ flatten(.) %>% str_c(., collapse = ', '))) %>% 
  select(-data) %>% 
  kable(digits = 1, 
        col.names = c("Encuestador", "Total encuestas", "% sin georef.", "folios")) %>% 
  kable_estilo()
```

## Puntos de encuestas

```{r}
epsoc4_geo <- epsoc4 %>% 
  select(folio, sbj.num, region, srvyr, longitude, latitude) %>% 
  filter(!is.na(latitude)) %>% 
  sf::st_as_sf(coords = c('longitude', 'latitude'),
               crs = "+proj=longlat +ellps=GRS80")

sf::write_sf(epsoc4_geo,
             here::here('validacion_epsoc_b_puntos_respuesta.kml'),
             dataset_options=c("NameField=folio"),
             delete_dsn=TRUE)
```

### Antofagasta

```{r}
epsoc4_geo %>% 
  filter(region == 2) %>% 
  ggplot(aes(color = srvyr)) +
  geom_sf() 
```

### Temuco

```{r}
epsoc4_geo %>% 
  filter(region == 9) %>% 
  ggplot(aes(color = srvyr)) +
  geom_sf()
```

### Santiago

```{r}
epsoc4_geo %>% 
  filter(region == 13) %>% 
  ggplot(aes(color = srvyr)) +
  geom_sf()
```

# Experimentos

EPSOC contiene dos experimentos que constituyen un foco de análisis del instrumento. El primer experimento consiste en un diseño factorial a través viñetas. El segundo se trata de una aleatorización del orden de preguntas sobre recompensa percibida y justa para tres objetos de evaluación: un obrero, un presidente de empresa y el respondente. Actualmente no es posible validar estos experimento por falta de información.

## Viñetas

Para validar el proceso con las viñetas necesitamos:

- Una breve explicación de cómo está codificado el experimento de las viñetas en la base de datos
- La base de datos que asocia los folios con sets de viñeta en orden presentado
- Acceso a grabaciones de voz durante el proceso de entrevista para asegurarnos que están bien asociadas las escalas con las variables

### Duración ejercicio

- Los marcadores de tiempo `time2` y `time3` no siguen un formato homogéneo para registrar la hora. Por ejemplo, en algún caso se utiliza el formato "2018-10-27T19:05:08-03:00" y en otros "Fri Oct 19 13:01:59 -0300 2018"
- Homogeneizar formatos de tiempos y fechas a ISO8601


```{r comienzo viñeta, warning=F}
## Comienzo viñetas
epsoc4$time2.hms <- hms::as.hms(epsoc4$time2)
epsoc4$time2.dmy <- date(epsoc4$time2)

## Fin viñetas
epsoc4$time3.hms <- hms::as.hms(epsoc4$time3)
epsoc4$time3.dmy <- date(epsoc4$time3)

epsoc4$dura.vinetas <- difftime(epsoc4$time3, epsoc4$time2,
                               units = "mins")

ggplot(epsoc4, aes(x = time2.dmy, y = time2.hms)) + geom_point() +
        labs(x = "Día", y = "Hora") + 
        ggtitle("Día y hora comienzo actividad viñetas") + 
        theme_bw()
```

```{r comienzo encuestador, warning=F}
ggplot(epsoc4, aes(x = srvyr, y = time2.hms)) + 
  geom_point() +
  labs(x = "Encuestador", y = "Hora") + 
  ggtitle("Hora comienzo actividad viñetas según encuestador") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90))

```
```{r plot.dura, message = F}
epsoc4 %>% 
  mutate(vin.cort = ifelse(dura.vinetas < 5, "< 5'", ">= 5'")) %>% 
  ggplot(aes(dura.vinetas)) + 
  geom_histogram(aes(fill = vin.cort)) + theme_bw() +
  theme(legend.title=element_blank()) +
  ggtitle("Duración ejercicio viñetas") +
  xlab("Minutos")
```

Como se puede ver en la figura anterior, la distribución del tiempo de duración del ejercicio de viñetas es variable. En términos de validación, llama la atención que se logre realizar el ejercicio en menos de cinco minutos. Estos casos deberían ser revisados apenas sea posible.


```{r plot.dura.enc}
ggplot(epsoc4, aes(x = srvyr, y = dura.vinetas, 
                   colour = as_factor(region), shape = status)) + 
  geom_point(alpha = 0.5,
             position = position_jitter(width = .2)) +
  labs(x = "Encuestador", y = "minutos") + 
  ggtitle("Duración de actividad viñetas según encuestador según región") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  facet_grid(cols = vars(region), scales = 'free_x', space = 'free_x')
```

En particular, deben supervisarse las siguientes entrevistas donde el ejercicio duró menos de 10 minutos:

```{r}
kable(epsoc4 %>% 
        group_by(srvyr) %>% 
        mutate(n.enc = length(folio)) %>% 
        select(folio, dura.vinetas, srvyr, n.enc) %>% 
        filter(dura.vinetas <= 10) %>%
        mutate(n.enc.cort = (length(folio)/n.enc)*100) %>% 
        arrange(srvyr, dura.vinetas), 
      digits = 1,
      col.names = c("Folio", "Duración viñetas", "Encuestador", "Total encuestas", "% cortas"),
      caption = "Ejercicio viñetas de menos de 10 minutos") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width=F) #%>% 
#column_spec(1, width = "10em") %>% 
#column_spec(2, width = "10em") %>% 
#column_spec(3, width = "10em")
```

## Evaluación de justicia

Para validar el experimento de evaluación de justicia necesitamos:
- Una breve explicación de cómo están codificados los items de recompensa percibida y recompensa justa para un obrero, el presidente de una empresa y el respondente
- Es fundamental saber cuál es la variable que define el orden en que se presentó una y otra pregunta

# Items justicia

La encuesta considera una serie de preguntas con escalas predefinidas. A continuación se revisa que los ítems sobre justicia tengan respuestas en el rango de 1 a 5 o bien valores de 8 o 9.

```{r}
item.just <- flatten_chr(labs.epsoc4[grep("usto", labs.epsoc4$label2),1])
v <- validator(j := var_group(i.6.a1, i.8.a1, i.9.a1,  i.10.a1, i.11.a1, i.12.a1,
                              i.13.a1, i.16.a1, i.1.h1, i.2.h1, i.5.h1, i.7.h1, 
                              i.8.h1, i.10.h1, i.11.h1, i.12.h1, i.14.h1), 
               j >= 1,
               j <= 9,
               j != 6,
               j != 7)
cf2 <- confront(epsoc4, v)
s.cf2 <- summary(cf2)
knitr::kable(s.cf2) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                      full_width=F)
```

Existen `r length(s.cf2$fails[s.cf2$fails > 0])` variables de actitudes sobre justicia fuera de rango.


# Otros criterios generales

Para validar los datos consideramos los siguientes criterios:  

- El rango etario de la población (18 a 59 años)
- Una duración de menos de dos horas
- Una duración de más de quince minutos
- Las variables con información redundante deben converger (edad y sexo)

```{r}
epsoc4$duration <- chron(times=epsoc4$duration)

cf <- check_that(epsoc4, edad.seleccionado <= 59 & edad.seleccionado >= 18,
                 sexo.enc == sexo.seleccionado)
s.cf <- summary(cf)
knitr::kable(s.cf) %>% 
        kable_estilo()
```


Resultados:

- `r ifelse(s.cf$fails[grep("edad", s.cf$expression)] == 0, 
       "No existen respondentes",
       paste("Existen", s.cf$fails[grep("edad", s.cf$expression)], "respondentes"))` fuera del rango etario.
- `r ifelse(s.cf$fails[grep("sexo", s.cf$expression)] == 0, 
       "No existen divergencias",
       paste("Existen", s.cf$fails[grep("sexo", s.cf$expression)], "divergencias"))` respecto al sexo del encuestado al comparar la variable `sexo.enc` y `sexo.seleccionado`.         



```{r edad}
## Fecha de nacimiento y edad seleccionado
epsoc4$enc.edad[as.character(epsoc4$enc.edad) == "1582-10-14"] <- NA # comportamiento extraño al importar desde SPSS
edad <- tibble(Folio = epsoc4$folio[is.na(epsoc4$enc.edad)],
        Fecha = epsoc4$enc.edad[is.na(epsoc4$enc.edad)],
        Edad = epsoc4$edad.seleccionado[is.na(epsoc4$enc.edad)]) 
knitr::kable(edad,
             caption = "Casos sin fecha de nacimiento en `enc_edad`",
             col.names = c("Folio", "Fecha nacimiento", "Edad")) %>% 
        kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                      full_width=F)
```

```{r sexo}
epsoc4 %>% 
  filter(sexo.enc != sexo.seleccionado) %>% 
  select(Folio = folio, sexo.enc, sexo.seleccionado) %>% 
  knitr::kable(col.names = c("Folio", "sexo.enc", "sexo.seleccionado"),
               caption = "Entrevistas donde sexo encuestado y seleccionado no coinciden") %>% 
  kable_estilo()
```

# Grabaciones

 Obtención de archivos de grabaciones de cada encuesta.

```{r, eval=Sys.info()[["user"]] %in% c('caayala', 'Andres')}
 path_general <- '../SurveyToGo Attachments/EPSOC 2018/'

 archivos <- dir(path = path_general, 
     pattern = str_c(epsoc4$sbj.num, collapse = '|'),
     recursive = TRUE)
 
 file.copy(from = str_c(path_general, archivos), 
           to = "grabaciones/",
           overwrite = TRUE)
```
